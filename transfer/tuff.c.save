#include <stdio.h>#include <net.h>#include <getopt.h>#include <stat.h>#define INADDR_ANY        0#define SIZEOFBUFFER    512#define SIZEOFFILENAME  512#define SIZEOFDIRECTORY 512#define SIZEOFDIRNAME   512#define MAXPATHLEN      128#define O_RDONLY         00#define O_WRONLY         01#define O_RDWR           02#define DOT_PER_LINE     80#define version "tuff version 0.2:1\n"#asm info Transfer UniFLEX (R) Files Program using ethernet info Copyright, (C) 2024-2025, by info Evenson Consulting Services info Version 1.2:1 5/27/2025 info All rights reserved.#endasmint terminate = 0;int fdBadBlock;/* cc tuff.c socklib.t.r getopt.r +o=tuff *//* tuff -i 10.0.0.128 -p 1410 */struct stat statBuffer;int c, len, status;struct sockaddr_in servaddr, cli;unsigned char *i_opt = NULL;unsigned char *p_opt = NULL;unsigned char *v_opt = NULL;unsigned char ackBuffer[2];unsigned char nakBuffer[2];unsigned char buffer[1024];unsigned char filename [SIZEOFFILENAME];unsigned char dir      [SIZEOFDIRECTORY];unsigned char commandLine [128];unsigned char badBlockFile [SIZEOFFILENAME];char ltoaBuffer[16];    int verbose = 1;    /* set default verbosity to show minimal entertainment */unsigned int crc_table[] ={    0x0000, 0x1021, 0x2042, 0x3063, 0x4084, 0x50a5, 0x60c6, 0x70e7,    0x8108, 0x9129, 0xa14a, 0xb16b, 0xc18c, 0xd1ad, 0xe1ce, 0xf1ef,    0x1231, 0x0210, 0x3273, 0x2252, 0x52b5, 0x4294, 0x72f7, 0x62d6,    0x9339, 0x8318, 0xb37b, 0xa35a, 0xd3bd, 0xc39c, 0xf3ff, 0xe3de,    0x2462, 0x3443, 0x0420, 0x1401, 0x64e6, 0x74c7, 0x44a4, 0x5485,    0xa56a, 0xb54b, 0x8528, 0x9509, 0xe5ee, 0xf5cf, 0xc5ac, 0xd58d,    0x3653, 0x2672, 0x1611, 0x0630, 0x76d7, 0x66f6, 0x5695, 0x46b4,    0xb75b, 0xa77a, 0x9719, 0x8738, 0xf7df, 0xe7fe, 0xd79d, 0xc7bc,    0x48c4, 0x58e5, 0x6886, 0x78a7, 0x0840, 0x1861, 0x2802, 0x3823,    0xc9cc, 0xd9ed, 0xe98e, 0xf9af, 0x8948, 0x9969, 0xa90a, 0xb92b,    0x5af5, 0x4ad4, 0x7ab7, 0x6a96, 0x1a71, 0x0a50, 0x3a33, 0x2a12,    0xdbfd, 0xcbdc, 0xfbbf, 0xeb9e, 0x9b79, 0x8b58, 0xbb3b, 0xab1a,    0x6ca6, 0x7c87, 0x4ce4, 0x5cc5, 0x2c22, 0x3c03, 0x0c60, 0x1c41,    0xedae, 0xfd8f, 0xcdec, 0xddcd, 0xad2a, 0xbd0b, 0x8d68, 0x9d49,    0x7e97, 0x6eb6, 0x5ed5, 0x4ef4, 0x3e13, 0x2e32, 0x1e51, 0x0e70,    0xff9f, 0xefbe, 0xdfdd, 0xcffc, 0xbf1b, 0xaf3a, 0x9f59, 0x8f78,    0x9188, 0x81a9, 0xb1ca, 0xa1eb, 0xd10c, 0xc12d, 0xf14e, 0xe16f,    0x1080, 0x00a1, 0x30c2, 0x20e3, 0x5004, 0x4025, 0x7046, 0x6067,    0x83b9, 0x9398, 0xa3fb, 0xb3da, 0xc33d, 0xd31c, 0xe37f, 0xf35e,    0x02b1, 0x1290, 0x22f3, 0x32d2, 0x4235, 0x5214, 0x6277, 0x7256,    0xb5ea, 0xa5cb, 0x95a8, 0x8589, 0xf56e, 0xe54f, 0xd52c, 0xc50d,    0x34e2, 0x24c3, 0x14a0, 0x0481, 0x7466, 0x6447, 0x5424, 0x4405,    0xa7db, 0xb7fa, 0x8799, 0x97b8, 0xe75f, 0xf77e, 0xc71d, 0xd73c,    0x26d3, 0x36f2, 0x0691, 0x16b0, 0x6657, 0x7676, 0x4615, 0x5634,    0xd94c, 0xc96d, 0xf90e, 0xe92f, 0x99c8, 0x89e9, 0xb98a, 0xa9ab,    0x5844, 0x4865, 0x7806, 0x6827, 0x18c0, 0x08e1, 0x3882, 0x28a3,    0xcb7d, 0xdb5c, 0xeb3f, 0xfb1e, 0x8bf9, 0x9bd8, 0xabbb, 0xbb9a,    0x4a75, 0x5a54, 0x6a37, 0x7a16, 0x0af1, 0x1ad0, 0x2ab3, 0x3a92,    0xfd2e, 0xed0f, 0xdd6c, 0xcd4d, 0xbdaa, 0xad8b, 0x9de8, 0x8dc9,    0x7c26, 0x6c07, 0x5c64, 0x4c45, 0x3ca2, 0x2c83, 0x1ce0, 0x0cc1,    0xef1f, 0xff3e, 0xcf5d, 0xdf7c, 0xaf9b, 0xbfba, 0x8fd9, 0x9ff8,    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0};int usage(){    fprintf(stderr,"usage: tuff [-p server-Port] [-i bind-to-IP] [-v (0-3)] \n");    fprintf(stderr,"        default port = 1410 ip = 10.0.0.128\n");    exit(1);}char *ltoa(value) long value; {    char *p;    char *start;    char *end ;    char temp;    int neg;        p = ltoaBuffer;    neg = 0;        if (value < 0)     {        neg = 1;        value = -value;    }    /* Build the number in reverse */    start = p;    do     {        *p++ = '0' + (value % 10);        value /= 10;    } while (value);    if (neg)        *p++ = '-';    *p = '\0';    /* Reverse the ltoaBuffering */    end = p - 1;    while (start < end)     {        temp = *start;        *start++ = *end;        *end-- = temp;    }    return ltoaBuffer;}char* inet_ntoa(ip)  int ip;{  unsigned char result[16];  sprintf(result, "%d.%d.%d.%d",    (ip >> 24) & 0xFF,    (ip >> 16) & 0xFF,    (ip >>  8) & 0xFF,    (ip      ) & 0xFF);  return result;}unsigned char *getcwd (){  unsigned char buf[MAXPATHLEN];  unsigned char *result;  FILE* fp;  buf[0] = 0x00;  if ((fp = popen ("/bin/pwd", "r")) == NULL)  {        fprintf(stderr, "Can't open /bin/pwd!\n");        exit(-1);  }  result = fgets(buf, MAXPATHLEN-1, fp);  pclose (fp);  if (strlen(buf) > 0)    buf[strlen(buf) - 1] = 0x00; /* remove the <cr> */  return (buf);}unsigned int CalcCCITT (data, startIndex, length, seed, final)unsigned char *data;int startIndex;int length;unsigned int seed;unsigned int final;{  int count;  unsigned int crc;  unsigned int temp;  int dataindex;  crc = seed;  dataindex = startIndex;  for (count = 0; count < length; ++count)  {    temp = (data[dataindex++] ^ (crc >> 8)) & 0xff;    crc = crc_table[temp] ^ (crc << 8);  }  return (unsigned int)(crc ^ final);}/* returns  1 if a directory exists with this name              *//* returns  0 if directory does not exists but a file does      *//* retuens -1 if stat fails - no file or directory by this name */int directoryExists (dirName)unsigned char *dirName;{  int returnValue;  /* dirname might be a directory name or a file name */  /* stat will check for either */  returnValue = stat(dirName, &statBuffer);  if (returnValue == 0) /* 0 is good status from stat call */  {      /* we found a directory entry name  that macthes  */      /* if this is a directory - return 1              */      /*              otherwise - return 0              */      if ((statBuffer.st_mode & 0x0900) == 0x0900)          returnValue = 1;      /* found a directory by this name */      else          returnValue = 0;      /* found a file by this name */  }  else      returnValue = -1; /* failed stat call - no file or directory */  return (returnValue);}int fileExists(filename)unsigned char *filename;{  return access(filename, 0) != -1;}int CreateFile (filename)unsigned char *filename;{  int fdFile;  /* if the file exists - delete it */  if (fileExists (filename))  {    unlink(filename);  }  fdFile = creat(filename, 0x7F); /* create with all permissions set */  if (fdFile == -1)  {    /* file was not created - report error*/    printf ("could not create file: %s", filename);  }  return (fdFile);}/* This is used to get both the size and the CCITT from the buffer*/int GetWord (buff, offset)  unsigned char *buff;  int offset;{  unsigned int value = 0;  value = (buff[offset] * 256) + buff[offset + 1];  return (value);}/* the packet will be in buffer for bytesRead number of bytes */void recvFile(sockfd, buff, bytesRead)  int sockfd;  unsigned char *buff;  int bytesRead;  {      /* process receipt of the file name that is in buffer along with the command byte */      int i;      int currentBlock;      int fdFile;      int size;      unsigned int recv_ccitt;      unsigned int calc_ccitt;      int retryCount;      int statReturn;      int proceed;      int bufferOffset = 1;   /* skip the command byte */      /* remote will be sending a filename */      for (i = 0; i < SIZEOFFILENAME; i++)      {          filename[i] = buff[bufferOffset++];          /* remote will send 0x00 to end input of filename */          if (filename[i] == 0x00)              break;      }      /* we need to see if the filename includes */      /* any directory paths (/)                 */      for (i = 0; i < strlen(filename); i++)      {          /* see if there is a directory that needs */          /* to be created */          if (filename[i] == '/' && i > 0)          {              if (verbose > 0)                  printf("found slash at offset %d in filename\n", i);              filename[i] = 0x00;     /* terminate */              statReturn = directoryExists(filename);              switch (statReturn)              {              case 1:                  if (verbose > 0)                      printf("directory %s already exists\n", filename);                  break;              case 0:              case -1:                  if (verbose > 0)                      printf("creating directory %s\n", filename);                  sprintf(commandLine, "mkdir %s", filename);                  system(commandLine);                  break;              }              filename[i] = '/';          }      }      /* do not proceed if the user passed in a filename instead of a directory name */      printf("creating file: %s\n", filename);      /* before we send the ACK to the file name, */      /* create the file and get ready to write   */      fdFile = CreateFile(filename);      /* now we can get the data for the file     */      /* the first thing that the remote will     */      /* send is the number of bytes in the block */      /*              when done, the remote will send a              block size of 0000      */      write(sockfd, ackBuffer, 1);  /* tell PC of to send data blocks */      currentBlock = 0;      bytesRead = read(sockfd, buff, 512);      while ((size = GetWord(buff, 0)) != 0)      {          bufferOffset += 2;  /* skip past word just read from buffer */          retryCount = 0;          currentBlock++;          /* now we have the size - get the data */          /* if the calcualted CCITT and the received CCITT   */          /* match, we will send an ACK and break out of this */          /* while loop and go up to the outer while loop     */          while (size > 0)          {              /* if this is a retry - get the size again */              if (retryCount > 0)          /* retries need new count   */                  size = GetWord(buff, 0);   /* size = 0 when PC is done */              retryCount++;              bufferOffset += size;                 /* skip past the data bytes to get to he CCITT */              recv_ccitt = GetWord(buff, size + 2); /* no need to update bufferOffset here */              calc_ccitt = CalcCCITT(buff, 2, size, 0xffff, 0);              if (recv_ccitt == calc_ccitt)              {                  retryCount = 0;    /* set to not retry this block */                  if (verbose > 2)                      printf("writing %d bytes to file for block %d\n", size, currentBlock);                  write(fdFile, buff + 2, size);                  /* we are done with time consuming stuff - send ACK */                  write(sockfd, ackBuffer, 1);  /* tell PC of to send the next data block */                  bytesRead = read(sockfd, buff, 512);                  break;                        /* break out of retry loop */              }              else              {                  /* write the bad block out to a file */                  sprintf(badBlockFile, "%s.%d.%d.bb", filename, currentBlock, retryCount);                  fdBadBlock = CreateFile(badBlockFile);                  write(fdBadBlock, buff + 2, size);                  close(fdBadBlock);                  /* report error - retry count was already set above */                  printf("CCITT received - %04x : calculated %04x\n"                      , recv_ccitt                      , calc_ccitt                  );                  write(sockfd, nakBuffer, 1);  /* tell PC of to re-send the last data block */                  bytesRead = read(sockfd, buff, 512);                  /* no break here - stay in retry loop */              }          }          if (size == 0)              break;      }      write(sockfd, ackBuffer, 1);  /* ACK the block size of zero */      if (verbose > 2)        printf("Closing file %s\n", filename);      close(fdFile);  }/* the packet will be in buffer for bytesRead number of bytes */void sndFile(sockfd, buff, bytesRead)  int sockfd;  unsigned char *buff;  int bytesRead;{    /* process receipt of the file name */    int i;    int fd;    int blockSize;    int blockNumber;    unsigned int ccitt;    unsigned char response [1];    unsigned char buffToSend[378];    unsigned char buf[256];    int bufferOffset;    long totalBlocks;    blockNumber  = 1;    bufferOffset = 1;    totalBlocks  = 0;    /* The first step is to accept the filename from the remote */    /* remote will be sending the name of the file to be sent   */    for (i = 0; i < SIZEOFFILENAME; i++)    {        /* remote will send 0x00 to end input of filename */        /* no need to delay writing ACK to null byte since*/        /* we will be initiating the next move            */        filename[i] = buff[bufferOffset++];        /* remote will send 0x00 to end input of filename */        if (filename[i] == 0x00)            break;    }    if (verbose > 2)        printf ("remote requesting file: %s", filename);    else        printf (" %s", filename);        /* need statBuffer.st_size for outputing dots */            if (stat(filename, &statBuffer) == 0) /* 0 is good status from stat call */    {        totalBlocks  = statBuffer.st_size / 256L;    /* get the number of 256 byte blocks to send */                    /* add a block if the file size is not an even multiple of the block size */        /* this will also make sure totalBlocks is NEVER = 0 */        if ((totalBlocks % 256) != 0 || totalBlocks == 0)            totalBlocks++;                /* McCosh C has trouble with printing lomgs with printd */        ltoa(totalBlocks);  /* the ascii string gets put into the gobal variable ltoaBuffer */        printf(" blocks: %s\n", ltoaBuffer);                /* receipt of the 0x00 character that means we have the filename */        /* the remote is now expecting start sending blocks of data              two byte file size              data[filesize]              CCITT            so - open the file and start sending blocks of data. send an            empty block (byte count = 0 with no data or CCITT to end        */        fd = open(filename, O_RDONLY);        if (fd != 0)        {            if (verbose > 1)                printf("opened file: %s\n", filename);            while (fd != 0) /* this is the block sending loop */            {                if (verbose > 2)                    printf("reading 256 bytes from file %s\n", filename);                blockSize = read(fd, buf, 256); /* get a block - up to 256 bytes at a time */                if (verbose > 2)                    printf("read %d bytes from %s\n", blockSize, filename);                while (blockSize > 0) /* this is the retry loop */                {                    if (verbose > 2)                        printf("calculating CCITT\n");                    ccitt = CalcCCITT (buf, 0, blockSize, 0xffff, 0);                    switch (verbose)                    {                        /*                          How it works:                            The expression (blockNumber * DOT_PER_LINE) / totalBlocks maps the current block to one of 0..DOT_PER_LINE-1.                            It only prints a dot when that mapping changes — i.e., once per dot "slot".                            So if totalBlocks = 1000    you get 80 dots total.                            If totalBlocks    = 40      you get 40 dots (one per block).                            If totalBlocks    = 100,000 you still get only 80 dots.                                                */                        case 1:                        case 2:                        /* we have already made sure totalBlocks  will NEVER be 0 */                            if ((blockNumber * DOT_PER_LINE) / totalBlocks != ((blockNumber - 1) * DOT_PER_LINE) / totalBlocks)                                printf(".");                            break;                        case 3:                            printf("sending %d bytes as block %d CCITT = %04x\n"                              , blockSize                              , blockNumber                              , ccitt);                            break;                    }                    /* send the blockSize to the remote if not zero*/                    /* we need to package up the size, data and CCITT into a buffer to send */                    bufferOffset = 0;                    buffToSend[bufferOffset++] = blockSize / 256;                    buffToSend[bufferOffset++] = blockSize % 256;                    for (i = 0; i < blockSize; i++)                      buffToSend[bufferOffset++] = buf[i];                    buffToSend[bufferOffset++] = (unsigned char)(ccitt / 256);                    buffToSend[bufferOffset++] = (unsigned char)(ccitt % 256);                    write(sockfd, buffToSend, bufferOffset);                    /* now wait for ACK or NAK to data just sent */                    read(sockfd, response, 1);                    if (response[0] == 0x06)                    {                        blockNumber++;                        break;  /* out of retry loop - do next block */                    }                }                /* if we get blockSize = 0 then we are done */                if (blockSize == 0)                {                    buffToSend[0] = 0x00;                    buffToSend[1] = 0x00;                    break;                }            }            /* now send the an empty block */            write(sockfd, buffToSend, 2);            /* and close the file */            close (fd);            switch (verbose)            {                case 1:                case 2:                    printf("\n");                    break;                case 3:                    printf("closed the file and sent empty block\n");                    break;            }        }    }    else    {        printf(" failed to get file info for %s\n", filename);                /* need to do this so that remote does not hang in a timeout */        buffToSend[0] = 0x00;        buffToSend[1] = 0x00;        write(sockfd, buffToSend, 2);    }}void sendFileInfo(sockfd, filename)  int sockfd;  unsigned char *filename;{    int i;    unsigned char response[1];    unsigned char *statPtr;    unsigned char byteToSend[1];    unsigned char buffToSend[256];    int fnLength = 0;    if (verbose > 2)        printf("waiting for remote to request a filename\n");        read(sockfd, response, 1); /* wait for remote to ask for filename */    if (response[0] == 0x06)    {        /* first send the statBuffer */        if (verbose > 2)            printf("sending statBuffer and filename\n");        /* we need to buffer the stat and filename together before sending */        statPtr = &statBuffer;        for (i = 0; i < 24; i++)        {            buffToSend[i] = statPtr[i];        }        /* now buffer the filename - there will always be a null byte */        for (i = 0; i < 16; i++)        {          buffToSend[i + 24] = filename[i];          buffToSend[i + 24 + 1] = 0x00;        }        fnLength = strlen(filename);        /* will have the count of bytes in the filename */        write(sockfd, buffToSend, 24 + fnLength + 1);    }    else      printf("non- ACK received: %02x\n", response[0]);}/* the packet will be in buffer for bytesRead number of bytes */void sendDirectory(sockfd, buff, bytesRead)  int sockfd;  unsigned char *buff;  int bytesRead;{    /* process receipt of the directory name */    int i;    int fdParent;    int deFDN;    unsigned char dirEntry[16];    unsigned char buf[32];    unsigned char filename[15];    unsigned char *cwd;    unsigned char tempbuf[MAXPATHLEN];    int fdDir;    int count;    int usingcwd;    int statReturn;    int proceed;    int bufferOffset = 1;    unsigned char response[1];    /*          struct stat structure returned by stat (size = 21)          {              int   st_dev ;    /* 0x00 - device number                 */              int   st_ino ;    /* 0x02 - fdn number                    */              unsigned st_mode; /* 0x04 - file mode and permissions     */              char st_nlink;    /* 0x06 - file link count               */              int st_uid;       /* 0x07 - file owner's user id          */              long st_size;     /* 0x09 - file size in bytes            */              long st_mtime;    /* 0x0D - last modified time            */              long st_spr;      /* 0x11 - spare - future use only       */                                /* 0x15 -     next byte after           */          };    */    /* remote will be sending a directory to browse */    for (i = 0; i < SIZEOFDIRECTORY; i++)    {        dir[i] = buff[bufferOffset++];      /* remote will send 0x00 to end input of directory name*/      if (dir[i] == 0x00)        break;    }    /* Get the list of files in this directory before sending the ACK */    /* for now just display a message */    if (strlen(dir) > 0)    {        /* first we MUST make sure that the string passed in is actually a directory */        statReturn = directoryExists(dir);        switch (statReturn)        {        case 1:     /* directory exists */            proceed = 1;            printf("directory exists\n");            break;        case 0:     /* directory does not exist, but a file with that name does */            proceed = 0;            printf("directory does not exists, but a normal file does\n");            break;        case -1:    /* neither a directory or normal file exists with specified name */            printf("neither a directory nor a normal file exists\n");            proceed = 0;            break;        }        if (dir[0] == '/')    /* absolute path from root. */        {            printf("browsing absolute path: %s\n", dir);            usingcwd = 0;        }        else        {            printf("browsing relative path: %s\n", dir);            usingcwd = 0;        }    }    else  /* user did not specify a directory */    {        usingcwd = 1;        cwd = getcwd();        for (i = 0; i < strlen(cwd); i++)        {            dir[i] = cwd[i];            dir[i + 1] = 0x00;        }        printf("browsing <current directory> %s\n", dir);        proceed = 1;    }    if (proceed == 1)    {        /* do processing to get list and then ack the directory name */        if (verbose > 2)            printf("openning %s\n", dir);        fdDir = open(dir, O_RDONLY);        if (fdDir != 0)        {            if (verbose > 2)                printf("opened %s - skipping '.' directory\n", dir);            count = read(fdDir, buf, 16);    /* skip the . directory */            /* now send the ACK - tells remote to start requesting filenames */            if (verbose > 2)                printf("sending ACK to tell remote it is OK to start requesting filenames\n");                        write(sockfd, ackBuffer, 1);  /* send ACK to tell PC OK to start requesting filenames */            while (count > 0)            {                count = read(fdDir, dirEntry, 16);        /* get a directory entry */                if (count == 16)                {                    deFDN = dirEntry[0] * 256 + dirEntry[1];  /* get FDN for this file */                    /* if the FDN is not zero - then it is valid */                    /* and we have a filename */                    if (deFDN != 0x00)                    {                        if (verbose > 2)                            printf("FDN of file = %04x name = ", deFDN);                        for (i = 0; i < 14; i++)                            filename[i] = dirEntry[i + 2];                        filename[14] = 0x00;                        tempbuf[0] = 0x00;   /* make sure tempbuf is terminated */                        if (usingcwd == 0)                        {                            strcpy(tempbuf, dir);                            strcat(tempbuf, "/");                        }                        strcat(tempbuf, filename);                        if (verbose > 2)                            printf("%s\n", filename);                        stat(tempbuf, &statBuffer);  /* we need full path for stat */                        sendFileInfo(sockfd, filename); /* will wait for the request */                    }                }            }            if (verbose > 2)                printf("telling remote to stop requesting filenames\n");            /* when we are done - send a statBuffer with all zeros and and a blank filename */            statBuffer.st_dev = 0;            statBuffer.st_ino = 0;            statBuffer.st_mode = 0;            statBuffer.st_nlink = 0;            statBuffer.st_uid = 0;            statBuffer.st_size = 0;            statBuffer.st_mtime = 0;            statBuffer.st_spr = 0;            for (i = 0; i < 16; i++)                filename[i] = 0x00;            sendFileInfo(sockfd, filename); /* will wait for the request */            close(fdDir);        }        else        {            printf("could not open '.' file\n");            write(sockfd, ackBuffer, 1);  /* ACK the directory name */        }    }    else    {        /* not a valid dieectory - now send the ACK - tells remote to start requesting filenames */        if (verbose > 2)            printf("sending ACK to tell remote it is OK to start requesting filenames\n");                write(sockfd, ackBuffer, 1);  /* send ACK to tell PC OK to start requesting filenames */        if (verbose > 2)            printf("telling remote to stop requesting filenames\n");        /* when we are done - send a statBuffer with all zeros and and a blank filename */        statBuffer.st_dev = 0;        statBuffer.st_ino = 0;        statBuffer.st_mode = 0;        statBuffer.st_nlink = 0;        statBuffer.st_uid = 0;        statBuffer.st_size = 0;        statBuffer.st_mtime = 0;        statBuffer.st_spr = 0;        for (i = 0; i < 16; i++)            filename[i] = 0x00;        sendFileInfo(sockfd, filename); /* will wait for the request */    }}/* get the current working directory and send back to remote   as a null terminated string */void sndCurrDir(sockfd, buff, bytesRead)  int sockfd;  unsigned char *buff;  int bytesRead;{    unsigned char *cwd;    cwd = getcwd();    write(sockfd, cwd, strlen(cwd) + 1);  /* send the null terminator as well */}/* handle requests (commands) from the client using sockfd */int func(sockfd)  int sockfd;{    int n;    int bytesRead = 0;    char command;    printf("entering command processor loop\n");        for (;terminate == 0;)    {        bzero(buffer, sizeof(buffer));        if (verbose > 2)            printf("waiting for remote to issue command\n");        else            printf(":");        bytesRead = read(sockfd, buffer, sizeof(buffer));        if (bytesRead > 0)        {            if (verbose > 2)            {                printf("bytes read from socket = %d\n", bytesRead);                printf("remote issued a command\n");                printf("received: %02x\n", buffer[0]); /* Print the read data  */            }            command = buffer[0];            /* the command buffer will also contain the information to start               processing the command:                  0x02 - null terminated file name to create and write                         after the receipt of the filename is ACKed, the                         client will loop on sending blocks of data                            size byte hi                            size byte lo                            data bytes (count = size)                            CCITT hi byte                            CCITT low byte                         until the entire file is send from the client                  0x03 - null terminated directory name to report on                         after the receipt of the filename is ACKed, the                         client (PC) will start sending ACK character to request                         the next file information. This will consist of 24                         bytes of information from stat that defines the file                         info and then the null terminated filename. This will                         continue until we send a 24 byte status buffer of all                         zeroes and an empty filename. Basically 25 bytes of 0.                  0x04 - null terminated file name to open and send. We start                         by making sure we ACK the filename terminator byte.                         Once we do, the client will be expecting data packets                         in the following format:                            size byte hi                            size byte lo                            data bytes (count = size)                            CCITT hi byte                            CCITT low byte                         until the entire file is send from the client. To                         signal that there are no packets to send, we will send                         a size 0 and stop transmitting.                  0x05 - get the current working directory and return as a null                         terminated string to the remote.                                           0x55 - force program to terminate            */                        switch (command)            {                case 0x02:        /* receive a file from PC */                    recvFile(sockfd, buffer, bytesRead);                    break;                case 0x03:   /* send a directory listing to PC */                    sendDirectory(sockfd, buffer, bytesRead);                    break;                case 0x04:   /* send a file to the remote */                    sndFile(sockfd, buffer, bytesRead);                    break;                case 0x05:   /* send a file to the remote */                    sndCurrDir(sockfd, buffer, bytesRead);                    break;                case 0x55:   /* force tuff to terminate */                    {                        printf("sending ACK to command\n");                        write(sockfd, ackBuffer, 1);                        terminate = 1;                        break;                    }                default:                    {                        /* invalid command sent from remote - abort application */                        printf("Invalid command sent from remote %02x\n", command);                        write(sockfd, nakBuffer, 1);                        terminate = 1;                        break;                    }            }          /* after handling command - return ACK */          /*          printf("sending ACK to command\n");          write(sockfd, ackBuffer, 1);          */        }        else            break;    }    printf("leaving command processor loop\n");        return (bytesRead);}int main(argc, argv)  int argc;  unsigned char **argv;{    int sockfd;    int connfd;    int bytesRead = 0;    ackBuffer[0] = 0x06; ackBuffer[1] = 0x00;    nakBuffer[0] = 0x15; nakBuffer[1] = 0x00;    printf(version);    /* set the defaults for empty command line parameters */    i_opt = "10.0.0.128";    p_opt = "1410";    while ((c = getopt (argc, argv, "i:p:v:?")) != -1)    {        switch (c)        {            case 'i':                i_opt = optarg;                break;            case 'p':                p_opt = optarg;                break;            case 'v':                v_opt = optarg;                break;            case '?':                usage();        }    }    if (p_opt == NULL)    {        usage();    }    /* anything > 0 means show it */    if (v_opt != NULL)    {        verbose = atoi(v_opt);        printf("verbosity level = %d\n", verbose);    }    /* when remote hangs up - create a new socket and listener */    /* the only way to exit the program is with ^C */            for (;;)    {        sockfd = socket(AF_INET, SOCK_STREAM,0);        if (sockfd == -1)        {            printf("socket creation failed...\n");            exit(0);        }        else            printf("Socket successfully created..\n");        bzero(&servaddr, sizeof(struct servaddr));        servaddr.sin_family = AF_INET;        servaddr.sin_port   = atoi(p_opt);        if (i_opt != NULL)            servaddr.sin_addr = (uint32_t) inet_addr(i_opt) ;        else            servaddr.sin_addr = (uint32_t) INADDR_ANY;        /* Binding newly created socket to given IP and verification */        if ((bind(sockfd, &servaddr, sizeof(servaddr))) != 0)        {            printf("socket bind failed...\n");            exit(0);        }        else            printf("Socket successfully binded..\n");        /*            Now the server is ready to listen and verification            allow only 1 concurrent connection        */                status = listen(sockfd, 1);        if (errno != 0)        {            printf("Listen failed and returned %d. errno = %d\n", status, errno);            exit(0);        }        else            printf("Server listening..\n");        len = sizeof(cli);        /* Listener got a request to connect - Accept the connection from the client */        printf("accepting connection\n");        connfd = accept(sockfd, &cli, &len);        /* printf("Connection accepted on port %d from %s\n", cli.sin_port, inet_ntoa(cli.sin_addr)); */        if (connfd < 0)        {            printf("server accept failed\n");            exit(0);        }        else            printf("server accept successful\n");        for(;;) /* do this even after disconnect */        {            printf("Entering forever loop to process commands from client\n");            /* Function for chatting between client and server */            /* all of the functions used by func will use connfd */            bytesRead = func(sockfd);            if (bytesRead == 0)                break;                        if (terminate == 1)                break;        }                if (terminate == 1)            break;    }        /* After chatting close the socket  */    close(sockfd);}